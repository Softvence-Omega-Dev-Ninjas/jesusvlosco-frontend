import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import logo from "@/assets/logo.jpg";
import Swal from "sweetalert2";
import { formatTime } from "@/components/TimeSheets/timeSheetsUtils";
import { TimeSheetEntry } from "@/pages/TimeSheets";

export function exportDateRangeToPDF(
  allEntries: TimeSheetEntry[],
  range: { start: string; end: string }
) {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 15;
  const headerTop = 15;

  function drawHeader() {
    try {
      doc.addImage(logo, "JPEG", margin, headerTop, 40, 20);
    } catch {
      // Logo loading failed, continue without logo
    }
    doc.setFontSize(18);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(52, 73, 94);
    doc.text("CLOCK SHEET REPORT", pageWidth / 2, headerTop + 10, {
      align: "center",
    });

    doc.setDrawColor(52, 73, 94);
    doc.setLineWidth(0.5);
    doc.line(margin, headerTop + 22, pageWidth - margin, headerTop + 22);

    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    const infoBoxY = headerTop + 25;
    doc.rect(margin, infoBoxY, pageWidth - margin * 2, 20);

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(
      `Report Range: ${range.start} to ${range.end}`,
      margin + 5,
      infoBoxY + 7
    );
    doc.text(`Total Entries: ${allEntries.length}`, margin + 5, infoBoxY + 14);
    doc.text(
      `Generated: ${new Date().toLocaleDateString()}`,
      pageWidth - margin - 5,
      infoBoxY + 7,
      { align: "right" }
    );
    doc.text(`Generated by: Admin`, pageWidth - margin - 5, infoBoxY + 14, {
      align: "right",
    });

    return infoBoxY + 30;
  }

  let currentY = drawHeader();

  // Group entries by date
  const grouped: Record<string, TimeSheetEntry[]> = {};
  allEntries.forEach((entry) => {
    const date = entry.clockIn?.split("T")[0] || "Unknown";
    if (!grouped[date]) grouped[date] = [];
    grouped[date].push(entry);
  });

  const dates = Object.entries(grouped);

  dates.forEach(([date, entries], idx) => {
    // Before printing a new date header, check vertical space
    const estimatedNeeded = 30;
    if (currentY + estimatedNeeded > pageHeight - margin - 40) {
      doc.addPage();
      currentY = drawHeader();
    }

    // Date heading (smaller gap above, more gap below after summary)
    doc.setFontSize(13);
    doc.setFont("helvetica", "bold");
    currentY += 4;
    doc.text(`Date: ${date}`, margin, currentY);
    currentY += 6;

    // Prepare table data
    const tableData = entries.map((entry) => [
      entry?.user?.name || "N/A",
      entry?.shift?.title || "N/A",
      formatTime(entry?.clockIn),
      formatTime(entry?.clockOut),
      entry?.totalHours || "0",
      entry?.regularHours || "0",
      entry?.overTime || "0",
    ]);

    autoTable(doc, {
      head: [
        [
          "Employee Name",
          "Shift",
          "Clock In",
          "Clock Out",
          "Total Hours",
          "Regular Hours",
          "Overtime",
        ],
      ],
      body: tableData,
      startY: currentY + 2, // LESS gap between date and table
      theme: "striped",
      margin: { left: 15, right: 15 },
      tableWidth: "auto",
      styles: {
        fontSize: 9,
        cellPadding: 4,
        overflow: "linebreak",
        halign: "center",
      },
      headStyles: {
        fillColor: [52, 73, 94],
        textColor: [255, 255, 255],
        fontStyle: "bold",
        fontSize: 10,
        halign: "center",
      },
      bodyStyles: {
        fontSize: 9,
        halign: "center",
      },
      alternateRowStyles: {
        fillColor: [249, 249, 249],
      },
      columnStyles: {
        0: { cellWidth: 40 },
        1: { cellWidth: 25 },
        2: { cellWidth: 25 },
        3: { cellWidth: 25 },
        4: { cellWidth: 20 },
        5: { cellWidth: 25 },
        6: { cellWidth: 25 },
      },
    });

    // Use lastAutoTable.finalY to get where table ended
    const finalY =
      (doc as jsPDF & { lastAutoTable?: { finalY: number } }).lastAutoTable
        ?.finalY || currentY + 50;

    // Summary for this date
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    // LARGER gap below summary before next date
    doc.text(`Total Entries: ${entries.length}`, margin, finalY + 16);

    currentY = finalY + 28; // LARGER gap before next date

    if (currentY > pageHeight - margin - 40 && idx < dates.length - 1) {
      doc.addPage();
      currentY = drawHeader();
    }
  });

  // Footer with page numbers (dynamic width/height)
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    doc.line(margin, pageHeight - 20, pageWidth - margin, pageHeight - 20);

    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(100, 100, 100);

    doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin, pageHeight - 10, {
      align: "right",
    });
    doc.text("CONFIDENTIAL - Clock Sheet Report", margin, pageHeight - 10);
    doc.text(
      `Generated on ${new Date().toLocaleDateString()}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: "center" }
    );
  }

  const fileName = `Clock_Sheet_${range.start}_to_${range.end}.pdf`;
  doc.save(fileName);

  Swal.fire({
    title: "PDF Generated Successfully!",
    text: `Clock sheet for ${range.start} to ${range.end} has been downloaded.`,
    icon: "success",
    confirmButtonText: "OK",
    timer: 3000,
  });
}
